# JAVASCRIPT

- [scope](#scope)
- [AJAX](#AJAX)
- [CSR vs SSR vs SSG](#csr-vs-ssr-vs-ssg)
- [가비지 컬렉터](#가비지-컬렉터)

<br>

## scope

모든 식별자(변수, 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 참조되는 유효 범위가 결정 된다. 이를 **scope**라고 한다. 즉, 식별자의 유효한 범위를 말한다.

**종류**

- 전역 scope: 코드의 가장 바깥 영역
- 지역 scope: 함수나 블록의 안쪽 영역 (지역 변수는 자신의 지역 scope와 그 하위에서만 유효함)

**scope 체인**

변수를 참조할 때 자바스크립트 엔진은 scope 체인을 통해 변수를 참조하는 코드의 scope에서 시작하여 상위 scope 방향으로 이동하며 선언된 변수를 검색한다.

**scope의 레벨**

- 함수 레벨 scope: var 변수의 경우 블록 레벨의 scope를 무시하고 함수 단위에서만 scope를 만듬
- 블록 레벨 scope: const, let 변수에 경우 함수 레벨 뿐만 아니라 블록 레벨(if, for문 등) 단위에서 적용되는 scope를 만듬

<br>

## AJAX

`Asynchronous JavaScript And XML`은 서버로부터 웹페이지의 변경에 필요한 데이터만 비동기 방식으로 전송 받아 웹페이지를 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 변경할 필요가 있는 부분만 한정적으로 렌더링하는 방식을 말합니다.

![image-20230711051603457](https://raw.githubusercontent.com/ddullgi/image_sever/master/img/image-20230711051603457.png)

> **XMLHttpRequest**
>
> 서버와 상호작용하기 위해 사용되며 전체 페이지의 새로 고침 없이 데이터를 받아 올 수 있는 자바스크립트의 객체입니다. 이름과 달리 XML뿐만 아니라 모든 종류의 데이터를 받아올 수 있습니다.

## CSR vs SSR vs SSG

#### Client Side Rendering (CSR)

![CSR](https://miro.medium.com/v2/resize:fit:720/format:webp/1*CRiH0hUGoS3aoZaIY4H2yg.png)

CSR은 클라이언트 측에서 웹 페이지를 렌더링하는 방식입니다. 브라우저에서 HTML, CSS, JavaScript와 같은 모든 웹 페이지 요소를 다운로드한 후, 클라이언트 측에서 동적으로 페이지를 구성합니다. 이는 초기 로드 시간이 길지만, 이후에는 더 빠른 페이지 전환과 더 나은 사용자 경험을 제공합니다. CSR은 주로 React, Vue.js, AngularJS와 같은 프론트엔드 프레임워크와 함께 사용됩니다.

#### Server Side Rendering (SSR)

![SSR](https://miro.medium.com/v2/resize:fit:720/format:webp/1*jJkEQpgZ8waQ5P-W5lhxuQ.png)

SSR은 서버에서 웹 페이지를 완전히 렌더링한 후 클라이언트에게 전달하는 방식입니다. 서버는 HTML, CSS, JavaScript와 같은 모든 웹 페이지 요소를 렌더링하고 클라이언트에게 전달합니다. 이는 초기 로드 시간이 빠르지만, 서버 측에서 렌더링하는 데 필요한 리소스가 많아질 수 있습니다. SSR은 Next.js, Nuxt.js와 같은 프레임워크에서 주로 사용되며, 서버 측에서 데이터를 렌더링하기 때문에 검색 엔진 최적화(SEO)에 유리합니다.

#### Static Site Generation (SSG)

SSG는 빌드 시점에서 웹 페이지를 사전에 렌더링하여 정적인 HTML 파일을 생성하는 방식입니다. 개발자는 사전에 정의된 데이터 소스(예: Markdown 파일, 데이터베이스 등)에서 데이터를 가져와 페이지를 미리 렌더링합니다. 생성된 정적 파일은 서버에 배포되어 클라이언트에게 제공됩니다. SSG는 동적인 요청이 없을 경우 서버에 대한 부하가 없으며, 초기 로딩 속도가 매우 빠르고 캐싱을 활용할 수 있어 성능이 우수합니다. 주로 Next.js, Gatsby.js와 같은 프레임워크에서 사용되며, 정적인 컨텐츠에 적합합니다.

## 가비지 컬렉터

메모리 관리를 자동으로 처리하는 기능을 말합니다. C언어 처럼 개발자가 수동으로 메모리를 할당하고 해제하는 대신, 가비지 컬렉터가 더 이상 사용되지 않는 메모리를 감지하고 자동으로 해제하여 메모리 누수를 방지합니다.

자바스크립트의 가비지 컬렉터는 크게 두가지 방식으로 메모리를 관리합니다.

- reference counting: `어떤 다른 객체에도 참조되지 않는 객체`를 `더 이상 필요 없는 객체`라고 여깁니다. 이 오브젝트를 `가비지` 라고 부르며 메모리에서 해제하는 방법입니다. 하지만 순환 참조 되는 객체에 경우 더 이상 필요하지 않지만 서로 참조하고 있기 때문에 reference counting 방법으로는 해제할 수 없어 현대적인 자바스크립트 엔지에서는 이 방식을 사용하지 않습니다.
- Mark-and-sweep: 이 알고리즘은 `더 이상 필요 없는 객체`를 `닿을 수 없는 객체`로 정의합니다. roots 객체, 즉 전역 객체를 기준으로 전역 객체가 참조하는 모든 객체를 찾고 마킹합니다. 마킹되지않은 객체는 `닿을 수 없는 객체`이기 때문에 메모리에서 해제합니다. 이 방식의 경우 순환 참조 문제를 해결할 수 있습니다.
