# JAVASCRIPT

- [scope](#scope)
- [AJAX](#AJAX)
- [CSR vs SSR vs SSG](#csr-vs-ssr-vs-ssg)
- [가비지 컬렉터](#가비지-컬렉터)
- [프론트엔드 성능 측정](#프론트엔드-성능-측정)

<br>

## scope

모든 식별자(변수, 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 참조되는 유효 범위가 결정 된다. 이를 **scope**라고 한다. 즉, 식별자의 유효한 범위를 말한다.

**종류**

- 전역 scope: 코드의 가장 바깥 영역
- 지역 scope: 함수나 블록의 안쪽 영역 (지역 변수는 자신의 지역 scope와 그 하위에서만 유효함)

**scope 체인**

변수를 참조할 때 자바스크립트 엔진은 scope 체인을 통해 변수를 참조하는 코드의 scope에서 시작하여 상위 scope 방향으로 이동하며 선언된 변수를 검색한다.

**scope의 레벨**

- 함수 레벨 scope: var 변수의 경우 블록 레벨의 scope를 무시하고 함수 단위에서만 scope를 만듬
- 블록 레벨 scope: const, let 변수에 경우 함수 레벨 뿐만 아니라 블록 레벨(if, for문 등) 단위에서 적용되는 scope를 만듬

<br>

## AJAX

`Asynchronous JavaScript And XML`은 서버로부터 웹페이지의 변경에 필요한 데이터만 비동기 방식으로 전송 받아 웹페이지를 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 변경할 필요가 있는 부분만 한정적으로 렌더링하는 방식을 말합니다.

![image-20230711051603457](https://raw.githubusercontent.com/ddullgi/image_sever/master/img/image-20230711051603457.png)

> **XMLHttpRequest**
>
> 서버와 상호작용하기 위해 사용되며 전체 페이지의 새로 고침 없이 데이터를 받아 올 수 있는 자바스크립트의 객체입니다. 이름과 달리 XML뿐만 아니라 모든 종류의 데이터를 받아올 수 있습니다.

## CSR vs SSR vs SSG

#### Client Side Rendering (CSR)

![CSR](https://miro.medium.com/v2/resize:fit:720/format:webp/1*CRiH0hUGoS3aoZaIY4H2yg.png)

CSR은 클라이언트 측에서 웹 페이지를 렌더링하는 방식입니다. 브라우저에서 HTML, CSS, JavaScript와 같은 모든 웹 페이지 요소를 다운로드한 후, 클라이언트 측에서 동적으로 페이지를 구성합니다. 이는 초기 로드 시간이 길지만, 이후에는 더 빠른 페이지 전환과 더 나은 사용자 경험을 제공합니다. CSR은 주로 React, Vue.js, AngularJS와 같은 프론트엔드 프레임워크와 함께 사용됩니다.

#### Server Side Rendering (SSR)

![SSR](https://miro.medium.com/v2/resize:fit:720/format:webp/1*jJkEQpgZ8waQ5P-W5lhxuQ.png)

SSR은 서버에서 웹 페이지를 완전히 렌더링한 후 클라이언트에게 전달하는 방식입니다. 서버는 HTML, CSS, JavaScript와 같은 모든 웹 페이지 요소를 렌더링하고 클라이언트에게 전달합니다. 이는 초기 로드 시간이 빠르지만, 서버 측에서 렌더링하는 데 필요한 리소스가 많아질 수 있습니다. SSR은 Next.js, Nuxt.js와 같은 프레임워크에서 주로 사용되며, 서버 측에서 데이터를 렌더링하기 때문에 검색 엔진 최적화(SEO)에 유리합니다.

#### Static Site Generation (SSG)

SSG는 빌드 시점에서 웹 페이지를 사전에 렌더링하여 정적인 HTML 파일을 생성하는 방식입니다. 개발자는 사전에 정의된 데이터 소스(예: Markdown 파일, 데이터베이스 등)에서 데이터를 가져와 페이지를 미리 렌더링합니다. 생성된 정적 파일은 서버에 배포되어 클라이언트에게 제공됩니다. SSG는 동적인 요청이 없을 경우 서버에 대한 부하가 없으며, 초기 로딩 속도가 매우 빠르고 캐싱을 활용할 수 있어 성능이 우수합니다. 주로 Next.js, Gatsby.js와 같은 프레임워크에서 사용되며, 정적인 컨텐츠에 적합합니다.

## 가비지 컬렉터

메모리 관리를 자동으로 처리하는 기능을 말합니다. C언어 처럼 개발자가 수동으로 메모리를 할당하고 해제하는 대신, 가비지 컬렉터가 더 이상 사용되지 않는 메모리를 감지하고 자동으로 해제하여 메모리 누수를 방지합니다.

자바스크립트의 가비지 컬렉터는 크게 두가지 방식으로 메모리를 관리합니다.

- reference counting: `어떤 다른 객체에도 참조되지 않는 객체`를 `더 이상 필요 없는 객체`라고 여깁니다. 이 오브젝트를 `가비지` 라고 부르며 메모리에서 해제하는 방법입니다. 하지만 순환 참조 되는 객체에 경우 더 이상 필요하지 않지만 서로 참조하고 있기 때문에 reference counting 방법으로는 해제할 수 없어 현대적인 자바스크립트 엔지에서는 이 방식을 사용하지 않습니다.
- Mark-and-sweep: 이 알고리즘은 `더 이상 필요 없는 객체`를 `닿을 수 없는 객체`로 정의합니다. roots 객체, 즉 전역 객체를 기준으로 전역 객체가 참조하는 모든 객체를 찾고 마킹합니다. 마킹되지않은 객체는 `닿을 수 없는 객체`이기 때문에 메모리에서 해제합니다. 이 방식의 경우 순환 참조 문제를 해결할 수 있습니다.

## 프론트엔드 성능 측정

프론트엔드 성능 측정은 사용자 경험을 향상시키고 최적화를 추구하기 위한 매우 중요한 단계입니다. 구글의 조사 결과에 따르면 페이지 로딩 속도가 증가할수록 사용자들이 페이지를 떠나는 비율이 상승한다고 합니다. 특히 이러한 이탈율은 이커머스와 같이 이탈율이 매출에 직접적으로 영향을 미치는 업계에서 더욱 치명이게 작용합니다. 따라서 웹 개발 과정에서 성능 최적화는 절대로 무시할 수 없는 과제로, 사용자의 만족도와 비즈니스 성과에 큰 영향을 미칠 수 있습니다.

### 성능지표

성능 측정은 다양한 성능 지표를 통해 이루어집니다. 다음 지표들은 구글에서 제공하는 웹 성능 지표들로 웹페이지의 성능을 평가하고 개선하는데 중요한 역할을 합니다.

#### FCP (First Contentful Paint)

웹페이지의 첫번째 컴포넌트가 렌더링되기 시작하는 시간을 나타냅니다. 사용자가 페이지가 로딩되고 있다는 것을 인지할 수 있는 첫 번째 순간입니다.

**Google 권장 기준: 100ms 이내**

개선 방법

- 리소스 최적화: 크기가 큰 이미지 등의 리소스를 압축하거나 최소화 합니다.
- 코드 스플리팅: 페이지를 여러 개의 작은 번들로 분할 하여 초기 로딩 시간을을 줄입니다.

#### TTI (Time to Interactive)

페이지가 완전히 로딩되고 사용자와 상호 작용할 수 있는 상태가 되는 시간을 나타냅니다. 사용자가 페이지와 상호 작용하기 위해 기다리지 않도록 하는 데 중요합니다.

**Google 권장 기준: 300ms 이내**

개선 방법

- 리소스 비동기 로딩: 필요한 리소스를 비동기적으로 로딩하여 페이지의 빠른 렌더링을 돕습니다.
- 자바스크립트 최적화: 자바스크립트 코드를 최적화하고 불필요한 실행을 줄여 TTI를 빠르게 합니다.

#### LCP (Largest Contentful Paint)

뷰포트 내에서 가장 큰 콘텐츠 요소가 화면에 나타나기 시작하는 시간을 나타냅니다.페이지의 주요 콘텐츠가 언제 보여지는지를 나타내는 지표입니다.

**Google 권장 기준: 2.5s 이내**

개선 방법

- 이미지 최적화: 이미지 포맷을 선택하고, 이미지 크기를 최적화하여 빠른 로딩을 돕습니다.
- 레이지 로딩: 페이지에 필요한 콘텐츠 중에서 필수 콘텐츠를 먼저 로딩하고, 나머지 콘텐츠는 필요할 때 로딩합니다.
- CDN 활용

#### FID (First Input Delay)

사용자가 페이지와 상호 작용하려고 할 때부터 실제로 브라우저가 상호 작용에 응답하는 시간을 나타냅니다.

**Google 권장 기준: 100ms 이내**

개선 방법

- 이벤트 핸들링 최적화: 이벤트 핸들러를 최적화하여 브라우저가 블로킹되는 시간을 최소화합니다.
- 웹 워커 활용: 긴 작업을 웹 워커로 분리하여 메인 스레드의 블로킹을 방지합니다.

#### CLS (Cumulative Layout Shift)

페이지의 레이아웃이 얼마나 안정적이지 않은지를 나타냅니다. 일정기간동안 레이아웃 이동이 없는 상태에서 발생하는 예상하지 않은 레이아웃 이동에 대한 누적된 점수입니다. 뷰포트에서 이동한 콘텐츠의 양과 영향을 받은 요소가 이동한 거리를 확인합니다.

**Google 권장 기준: 0.1 이내**

개선방법

- 이미지 크기 지정: 이미지의 크기를 미리 지정하여 이미지 로딩으로 인한 레이아웃 이동을 방지합니다.
- 광고 및 외부 콘텐츠 공간확보
- 애니메이션 최적화: 애니메이션의 크기와 속도를 최적화하여 레이아웃 변화를 최소화합니다.

### 성능 측정 방법

프론트엔드 성능을 측정하고 최적화하기 위해 다양한 도구와 방법을 활용할 수 있습니다. 아래에는 주로 사용되는 방법들을 소개합니다.

#### Performance Insights

크롬 개발자 도구의 "Performance" 탭은 실시간으로 웹 페이지의 성능을 모니터링하는데 유용한 도구입니다. 이 탭에서 로딩 시간, 렌더링 성능, 리소스 사용 등을 시각적으로 확인할 수 있습니다. 각각의 요청, 이벤트, 렌더링 단계를 타임라인 형식으로 볼 수 있어 문제 발생 지점을 찾는 데 도움이 됩니다.

#### Lighthouse

크롬 개발자 도구의 "Lighthouse" 기능은 웹 페이지의 성능 및 접근성을 평가하는 오픈 소스 도구입니다. Lighthouse는 여러 성능 지표를 자동으로 측정하고, 웹 페이지의 성능 점수를 제공합니다. 또한 성능 개선을 위한 구체적인 조언과 가이드를 제시해 줍니다.

#### Web Vitals

Google에서 개발한 웹 성능 지표인 "Web Vitals"는 웹 페이지의 사용자 경험을 측정하는데 사용됩니다. Largest Contentful Paint (LCP), First Input Delay (FID), Cumulative Layout Shift (CLS) 등으로 구성되어 있습니다. 웹 Vitals를 통해 사용자가 실제로 느끼는 성능을 평가하고 개선할 수 있습니다.
